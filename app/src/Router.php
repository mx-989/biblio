<?php

namespace App;

use App\Utils\Route;

class Router {
    protected array $routes = [];
    protected string $url;
    protected string $method;

    public function __construct() {
        // Parse the URL from the server request and store the path part of it.
        $this->url = parse_url($_SERVER['REQUEST_URI'], PHP_URL_PATH);

        // Store the HTTP method of the request (e.g., GET, POST).
        $this->method = $_SERVER['REQUEST_METHOD'];
    }

    public function registerControllers(array $controllers) {
        // We scan the controllers for attributes and register the routes
        foreach ($controllers as $controller) {
            $reflection = new \ReflectionClass($controller);
            foreach ($reflection->getMethods() as $method) {
                $attributes = $method->getAttributes(Route::class);
                foreach ($attributes as $attribute) {
                    $instance = $attribute->newInstance();
                    $this->register($instance->method, $instance->path, $controller, $method->getName());
                }
            }
        }
    }

    public function register(string $method, string $route, string $controller, string $controllerMethod) {
        // Store the route in the $routes array, under the specified HTTP method.
        // The route is associated with a controller and a method within that controller.
        $this->routes[$method][$route] = [$controller, $controllerMethod];
    }

    public function run() {
        // Initialize the response to null.
        $response = null;

        // Start output buffering. This means that any output generated by the script will be stored in a buffer
        // instead of being sent directly to the browser.
        ob_start();

        // Loop through all the routes registered for the current HTTP method.
        foreach ($this->routes[$this->method] as $route => $action) {
            // Check if the current URL matches the route.
            if ($this->matchRule($this->url, $route)) {
                // Extract the controller and method from the action.
                list($controller, $method) = $action;

                // Extract any parameters from the URL path.
                $pathParams = $this->extractParams($this->url, $route);

                // Extract query parameters from the URL.
                $queryParams = $_GET; // Automatically populated by PHP with query parameters.

                // Combine path and query parameters.
                $params = array_merge($pathParams, $queryParams);

                // Create a new instance of the controller, passing any parameters to it.
                $controllerInstance = new $controller($params);

                // Check if the method exists in the controller.
                if (method_exists($controllerInstance, $method)) {
                    try {
                        // Call the method on the controller instance with the parameters.
                        // The response is the result of this method call.
                        $response = call_user_func_array([$controllerInstance, $method], array_values($params));
                    } catch (\Exception $e) {
                        // If an exception occurs, set the response to an error message with a 500 status code.
                        http_response_code(500);
                        $response = ["error" => $e->getMessage()];
                    }
                } else {
                    // If the method does not exist, set the response to a "Method Not Allowed" error with a 405 status code.
                    http_response_code(405);
                    $response = ["error" => "Method Not Allowed"];
                }
                // Break the loop as we have found a matching route.
                break;
            }
        }

        // If no matching route was found, set the response to a "Not Found" error with a 404 status code.
        if ($response === null) {
            http_response_code(404);
            $response = ["error" => "Not Found"];
        }

        // End the output buffering and clean the buffer.
        ob_end_clean();

        // Set the content type of the response to JSON.
        header('Content-Type: application/json');

        // Output the response as a JSON string.
        echo json_encode($response);
    }

    protected function matchRule($url, $route) {
        // Split the URL and route into parts, trimming any leading or trailing slashes.
        $urlParts = explode('/', trim($url, '/'));
        $routeParts = explode('/', trim($route, '/'));

        // If the number of parts in the URL and route do not match, return false.
        if (count($urlParts) !== count($routeParts)) {
            return false;
        }

        // Loop through each part of the route.
        foreach ($routeParts as $index => $routePart) {
            // If the route part does not match the URL part and does not start with a colon (:), return false.
            if ($routePart !== $urlParts[$index] && strpos($routePart, ':') !== 0) {
                return false;
            }
        }

        // If all parts match, return true.
        return true;
    }

    protected function extractParams($url, $route) {
        // Initialize an empty array to store the parameters.
        $params = [];

        // Split the URL and route into parts, trimming any leading or trailing slashes.
        $urlParts = explode('/', trim($url, '/'));
        $routeParts = explode('/', trim($route, '/'));

        // Loop through each part of the route.
        foreach ($routeParts as $index => $routePart) {
            // If the route part starts with a colon (:) and there is a corresponding URL part, extract the parameter.
            if (strpos($routePart, ':') === 0 && isset($urlParts[$index])) {
                $paramName = substr($routePart, 1);
                $params[$paramName] = $urlParts[$index];
            }
        }

        // Return the extracted parameters.
        return $params;
    }
}